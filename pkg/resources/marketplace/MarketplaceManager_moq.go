// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package marketplace

import (
	"context"
	"github.com/operator-framework/operator-lifecycle-manager/pkg/api/apis/operators/v1alpha1"
	"github.com/operator-framework/operator-lifecycle-manager/pkg/lib/ownerutil"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sync"
)

var (
	lockMarketplaceInterfaceMockGetSubscriptionInstallPlans sync.RWMutex
	lockMarketplaceInterfaceMockInstallOperator             sync.RWMutex
	lockMarketplaceInterfaceMockUpdateAvailable             sync.RWMutex
)

// Ensure, that MarketplaceInterfaceMock does implement MarketplaceInterface.
// If this is not the case, regenerate this file with moq.
var _ MarketplaceInterface = &MarketplaceInterfaceMock{}

// MarketplaceInterfaceMock is a mock implementation of MarketplaceInterface.
//
//     func TestSomethingThatUsesMarketplaceInterface(t *testing.T) {
//
//         // make and configure a mocked MarketplaceInterface
//         mockedMarketplaceInterface := &MarketplaceInterfaceMock{
//             GetSubscriptionInstallPlansFunc: func(ctx context.Context, serverClient client.Client, subName string, ns string) (*v1alpha1.InstallPlanList, *v1alpha1.Subscription, error) {
// 	               panic("mock out the GetSubscriptionInstallPlans method")
//             },
//             InstallOperatorFunc: func(ctx context.Context, serverClient client.Client, owner ownerutil.Owner, t Target, operatorGroupNamespaces []string, approvalStrategy v1alpha1.Approval) error {
// 	               panic("mock out the InstallOperator method")
//             },
//             UpdateAvailableFunc: func(ctx context.Context, serverClient client.Client) (bool, string, error) {
// 	               panic("mock out the UpdateAvailable method")
//             },
//         }
//
//         // use mockedMarketplaceInterface in code that requires MarketplaceInterface
//         // and then make assertions.
//
//     }
type MarketplaceInterfaceMock struct {
	// GetSubscriptionInstallPlansFunc mocks the GetSubscriptionInstallPlans method.
	GetSubscriptionInstallPlansFunc func(ctx context.Context, serverClient client.Client, subName string, ns string) (*v1alpha1.InstallPlanList, *v1alpha1.Subscription, error)

	// InstallOperatorFunc mocks the InstallOperator method.
	InstallOperatorFunc func(ctx context.Context, serverClient client.Client, owner ownerutil.Owner, t Target, operatorGroupNamespaces []string, approvalStrategy v1alpha1.Approval) error

	// UpdateAvailableFunc mocks the UpdateAvailable method.
	UpdateAvailableFunc func(ctx context.Context, serverClient client.Client) (bool, string, error)

	// calls tracks calls to the methods.
	calls struct {
		// GetSubscriptionInstallPlans holds details about calls to the GetSubscriptionInstallPlans method.
		GetSubscriptionInstallPlans []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ServerClient is the serverClient argument value.
			ServerClient client.Client
			// SubName is the subName argument value.
			SubName string
			// Ns is the ns argument value.
			Ns string
		}
		// InstallOperator holds details about calls to the InstallOperator method.
		InstallOperator []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ServerClient is the serverClient argument value.
			ServerClient client.Client
			// Owner is the owner argument value.
			Owner ownerutil.Owner
			// T is the t argument value.
			T Target
			// OperatorGroupNamespaces is the operatorGroupNamespaces argument value.
			OperatorGroupNamespaces []string
			// ApprovalStrategy is the approvalStrategy argument value.
			ApprovalStrategy v1alpha1.Approval
		}
		// UpdateAvailable holds details about calls to the UpdateAvailable method.
		UpdateAvailable []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ServerClient is the serverClient argument value.
			ServerClient client.Client
		}
	}
}

// GetSubscriptionInstallPlans calls GetSubscriptionInstallPlansFunc.
func (mock *MarketplaceInterfaceMock) GetSubscriptionInstallPlans(ctx context.Context, serverClient client.Client, subName string, ns string) (*v1alpha1.InstallPlanList, *v1alpha1.Subscription, error) {
	if mock.GetSubscriptionInstallPlansFunc == nil {
		panic("MarketplaceInterfaceMock.GetSubscriptionInstallPlansFunc: method is nil but MarketplaceInterface.GetSubscriptionInstallPlans was just called")
	}
	callInfo := struct {
		Ctx          context.Context
		ServerClient client.Client
		SubName      string
		Ns           string
	}{
		Ctx:          ctx,
		ServerClient: serverClient,
		SubName:      subName,
		Ns:           ns,
	}
	lockMarketplaceInterfaceMockGetSubscriptionInstallPlans.Lock()
	mock.calls.GetSubscriptionInstallPlans = append(mock.calls.GetSubscriptionInstallPlans, callInfo)
	lockMarketplaceInterfaceMockGetSubscriptionInstallPlans.Unlock()
	return mock.GetSubscriptionInstallPlansFunc(ctx, serverClient, subName, ns)
}

// GetSubscriptionInstallPlansCalls gets all the calls that were made to GetSubscriptionInstallPlans.
// Check the length with:
//     len(mockedMarketplaceInterface.GetSubscriptionInstallPlansCalls())
func (mock *MarketplaceInterfaceMock) GetSubscriptionInstallPlansCalls() []struct {
	Ctx          context.Context
	ServerClient client.Client
	SubName      string
	Ns           string
} {
	var calls []struct {
		Ctx          context.Context
		ServerClient client.Client
		SubName      string
		Ns           string
	}
	lockMarketplaceInterfaceMockGetSubscriptionInstallPlans.RLock()
	calls = mock.calls.GetSubscriptionInstallPlans
	lockMarketplaceInterfaceMockGetSubscriptionInstallPlans.RUnlock()
	return calls
}

// InstallOperator calls InstallOperatorFunc.
func (mock *MarketplaceInterfaceMock) InstallOperator(ctx context.Context, serverClient client.Client, owner ownerutil.Owner, t Target, operatorGroupNamespaces []string, approvalStrategy v1alpha1.Approval) error {
	if mock.InstallOperatorFunc == nil {
		panic("MarketplaceInterfaceMock.InstallOperatorFunc: method is nil but MarketplaceInterface.InstallOperator was just called")
	}
	callInfo := struct {
		Ctx                     context.Context
		ServerClient            client.Client
		Owner                   ownerutil.Owner
		T                       Target
		OperatorGroupNamespaces []string
		ApprovalStrategy        v1alpha1.Approval
	}{
		Ctx:                     ctx,
		ServerClient:            serverClient,
		Owner:                   owner,
		T:                       t,
		OperatorGroupNamespaces: operatorGroupNamespaces,
		ApprovalStrategy:        approvalStrategy,
	}
	lockMarketplaceInterfaceMockInstallOperator.Lock()
	mock.calls.InstallOperator = append(mock.calls.InstallOperator, callInfo)
	lockMarketplaceInterfaceMockInstallOperator.Unlock()
	return mock.InstallOperatorFunc(ctx, serverClient, owner, t, operatorGroupNamespaces, approvalStrategy)
}

// InstallOperatorCalls gets all the calls that were made to InstallOperator.
// Check the length with:
//     len(mockedMarketplaceInterface.InstallOperatorCalls())
func (mock *MarketplaceInterfaceMock) InstallOperatorCalls() []struct {
	Ctx                     context.Context
	ServerClient            client.Client
	Owner                   ownerutil.Owner
	T                       Target
	OperatorGroupNamespaces []string
	ApprovalStrategy        v1alpha1.Approval
} {
	var calls []struct {
		Ctx                     context.Context
		ServerClient            client.Client
		Owner                   ownerutil.Owner
		T                       Target
		OperatorGroupNamespaces []string
		ApprovalStrategy        v1alpha1.Approval
	}
	lockMarketplaceInterfaceMockInstallOperator.RLock()
	calls = mock.calls.InstallOperator
	lockMarketplaceInterfaceMockInstallOperator.RUnlock()
	return calls
}

// UpdateAvailable calls UpdateAvailableFunc.
func (mock *MarketplaceInterfaceMock) UpdateAvailable(ctx context.Context, serverClient client.Client) (bool, string, error) {
	if mock.UpdateAvailableFunc == nil {
		panic("MarketplaceInterfaceMock.UpdateAvailableFunc: method is nil but MarketplaceInterface.UpdateAvailable was just called")
	}
	callInfo := struct {
		Ctx          context.Context
		ServerClient client.Client
	}{
		Ctx:          ctx,
		ServerClient: serverClient,
	}
	lockMarketplaceInterfaceMockUpdateAvailable.Lock()
	mock.calls.UpdateAvailable = append(mock.calls.UpdateAvailable, callInfo)
	lockMarketplaceInterfaceMockUpdateAvailable.Unlock()
	return mock.UpdateAvailableFunc(ctx, serverClient)
}

// UpdateAvailableCalls gets all the calls that were made to UpdateAvailable.
// Check the length with:
//     len(mockedMarketplaceInterface.UpdateAvailableCalls())
func (mock *MarketplaceInterfaceMock) UpdateAvailableCalls() []struct {
	Ctx          context.Context
	ServerClient client.Client
} {
	var calls []struct {
		Ctx          context.Context
		ServerClient client.Client
	}
	lockMarketplaceInterfaceMockUpdateAvailable.RLock()
	calls = mock.calls.UpdateAvailable
	lockMarketplaceInterfaceMockUpdateAvailable.RUnlock()
	return calls
}
